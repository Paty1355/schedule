from __future__ import annotations

from typing import Any, Dict, List

from .data_model.course import Course, Course_assignments, CourseType
from .data_model.group import Groups, GroupUnavailabilities
from .data_model.location import Rooms, RoomType
from .data_model.teacher import Teachers, Teacher_unavailabities
from .data_model.time_models import Time_slots, Weekdays


class GADataLoader:
    """Utility responsible for building GA-ready objects from repositories."""

    def __init__(self, repos: Dict[str, Any]):
        self.repos = repos

    def load(self) -> Dict[str, List[Any]]:
        """Load and convert database rows into Pydantic GA models."""
        rooms = self._load_rooms()
        courses = self._load_courses()
        groups = self._load_groups()
        teachers = self._load_teachers()
        course_assignments = self._load_course_assignments(courses, groups, teachers)
        teacher_unavailabilities = self._load_teacher_unavailabilities()
        group_unavailabilities = self._load_group_unavailabilities()

        return {
            "rooms": rooms,
            "courses": list(courses.values()),
            "groups": list(groups.values()),
            "teachers": list(teachers.values()),
            "course_assignments": course_assignments,
            "time_slots": [],  # Generated by genetic algorithm
            "teacher_unavailabilities": teacher_unavailabilities,
            "group_unavailabilities": group_unavailabilities,
        }

    def _load_rooms(self) -> List[Rooms]:
        rooms = []
        for row in self.repos["rooms"].get_all():
            rooms.append(
                Rooms(
                    id=row[0],
                    building_id=row[1],
                    code=row[2],
                    name=row[3],
                    capacity=row[4],
                    type=RoomType(row[5]),
                    note=row[6],
                    equipment=row[7] or [],
                    accessibility=row[8] or {},
                )
            )
        return rooms

    def _load_courses(self) -> Dict[int, Course]:
        courses: Dict[int, Course] = {}
        for row in self.repos["courses"].get_all():
            courses[row[0]] = Course(
                id=row[0],
                code=row[1],
                name=row[2],
                departament_id=row[3],
                type=CourseType(row[4]),
                hours_per_semester=row[5],
            )
        return courses

    def _load_groups(self) -> Dict[int, Groups]:
        groups: Dict[int, Groups] = {}
        for row in self.repos["groups"].get_all():
            groups[row[0]] = Groups(
                id=row[0],
                code=row[1],
                name=row[2],
                department_id=row[3],
                students_count=row[4],
                accessibility_requirements=row[5] or {},
                parent_group_id=row[6],
            )
        return groups

    def _load_teachers(self) -> Dict[int, Teachers]:
        teachers: Dict[int, Teachers] = {}
        for row in self.repos["teachers"].get_all():
            teachers[row[0]] = Teachers(
                id=row[0],
                first_name=row[1],
                last_name=row[2],
                department_id=row[3],
                accessibility=row[4] or {},
            )
        return teachers

    def _load_course_assignments(
        self,
        courses: Dict[int, Course],
        groups: Dict[int, Groups],
        teachers: Dict[int, Teachers],
    ) -> List[Course_assignments]:
        result: List[Course_assignments] = []
        for row in self.repos["course_assignments"].get_all():
            course = courses.get(row[1])
            group = groups.get(row[2])
            teacher = teachers.get(row[3])
            if not (course and group and teacher):
                # Skip dangling assignments that reference missing entities.
                continue
            result.append(
                Course_assignments(
                    id=row[0],
                    course_id=course,
                    group_id=group,
                    teacher_id=teacher,
                    semester=row[4],
                    note=row[5],
                )
            )
        return result

    def _load_time_slots(self) -> List[Time_slots]:
        slots = []
        for row in self.repos["time_slots"].get_all():
            slots.append(
                Time_slots(
                    id=row[0],
                    start_time=row[1],
                    end_time=row[2],
                    slot_order=row[3],
                    duration_minutes=row[4],
                )
            )
        return slots

    def _load_teacher_unavailabilities(self) -> List[Teacher_unavailabities]:
        unavs = []
        repository = self.repos.get("teacher_unavailabilities")
        if not repository:
            return unavs
        for row in repository.get_all():
            unavs.append(
                Teacher_unavailabities(
                    id=row[0],
                    teacher_id=row[1],
                    weekday=Weekdays(row[2]),
                    start_time=row[3],
                    end_time=row[4],
                    reason=row[5],
                )
            )
        return unavs

    def _load_group_unavailabilities(self) -> List[GroupUnavailabilities]:
        unavs = []
        repository = self.repos.get("group_unavailabilities")
        if not repository:
            return unavs
        for row in repository.get_all():
            unavs.append(
                GroupUnavailabilities(
                    id=row[0],
                    group_id=row[1],
                    weekday=Weekdays(row[2]),
                    start_time=row[3],
                    end_time=row[4],
                    reason=row[5],
                )
            )
        return unavs
